## Tarantool как основное хранилище данных для серверных Windows приложений, написанных на .net.

### Введение.

Здравствуйте! Меня зовут Анатолий Попов и в компании evote.com я отвечаю за разработку и эксплуатацию серверного кода. Расскажу я о нашем опыте использования Тарантула для серверных приложений, написанных на .net.

### Почему Тарантул?

Почему мы выбрали именно тарантул? Мы делаем продукт для сбора обратной связи и голосований, подробнее могу рассказать потом, доклад не об этом. Модель данных получается достаточно простой и укладывается в ограничения, которые на нас накладывают key-value хранилища и поэтому изначально у нас был Redis. Несмотря на простоту модели данных, достаточно скоро нам потребовалось искать голосования, созданные каким-то автором. То есть, фактически нам потребовались вторичные индексы. И мы их реализовали на редисе дополнительными списками. Достаточно скоро мы столкнулись с тем, что отстутствие атомарности при этих изменениях приводит к нарушению консистентности данных. Использование транзакций или луа в редисе значительно снижало производительность.

Тарантул мы рассматривали с самого начала, в нём есть вторичные индексы, у него хорошие показатели по перфомансу и, учитывая проблемы с данными в редисе, мы решили попробовать тарантул.

### Проблемы при разработке кода и их решение.

Во-первых, нет версии тарантул под Windows. Во-вторых, мы же дотнетчики, а дотнетного коннектора не было.

Решали мы эти проблемы достаточно в лоб: тарантул мы используем в докер-контейнерах, которые обвязаны докер-композом, а под .net мы написали и поддерживаем свой коннектор: https://github.com/progaudi/tarantool-csharp

Тут будет минутка пиара:
- коннектор доступен в nuget, поддерживает .net46 и .netstandard 1.4 для .net core.
- практически полностью поддерживаем протокол тарантула (в том числе, call16 и call), за исключением:
    - DDL
    - call v1.6, если функция возвращает null, приводит к исключению, я пока не придумал как это распарсить
    - коннект держим пока только с первой переданной в конфиге нодой, это будет исправлено в ближайшее время

### Проблемы при эксплуатации и их решение.

К сожалению, серебряной пули до сих пор не изобретено, поэтому вовремя эксплуатации Тарантула тоже возникли проблемы.

1. Нет синхронной репликации, поэтому возможна потеря небольшого количества данных, в случае выхода мастера из строя. Это для нас не критично, потому что в Редисе всё несколько хуже. Насколько мне известно, это будет исправлено в 2017м году.

2. На момент релиза 1.7.3 с поднятием кластера с одинаковой конфигурацией могут быть проблемы. Допустим, у нас простой кластер из трёх нод. Если все три ноды лежат и запускаем одновременно, то они не видят апстримы для репликации и через 30 секунд выключится. Это уже исправлено, мы просто никак не обновим продакшен.

3. Крайне неочевидна для нашей команды эксплутации связь между версией докер-контейнера и версией тарантула. Например, сейчас версия 1.7.3 контейнера зафиксирована, а текущая разработка тарантула продолжает разрабатываться. Мы перешли на самосборный контейнер.

4. Общий недостаток и Редиса, и Тарантула - это специфический язык запросов. В Тарантуле это Lua. Товарищи сисадмины и тестировщики более привычны к SQL. Работы над интеграцией движка SQL опять же, если я не ошибаюсь, запланированы.

### Достоинства Тарантула, с которыми мы столкнулись.

1. Тарантул быстр.
2. Запись в тарантул надёжна в плане durability. WAL всегда гарантирует, что ваша запись достигла диска.
3. Вторичные индексы. Для нас это на текущий момент очень важно и сильно помогает. Хотя, при росте объёмов данных и необходимости шардирования, с ними могут быть проблемы.
4. У него нет Windows-binary. Это всё-таки больше плюс, чем минус. Это заставляет разработчиков разбираться в той среде, в которой будут лежать их данные. Разбираться с контейнеризацией и прочими новыми и полезными технологиями. Что приводит к более работоспособному коду. Например, у Redis есть порт под Windows и мы его использовали в самом начале, чтобы не разбираться с Linux и использовать полностью Windows стек. Следствием стало то, что мы наткнулись на замечательный баг в нём, который приводил к падению в ходе создания снапшота. Старого нет, новый недописан. Спасали данные с реплик.
5. Унификация конфигураций для не очень больших (до 32 нод) кластеров, если вас устраивает мастер-мастер репликация.
6. Богатейшие возможности для использования тарантула в качестве сервера приложений. Мы используем, например, модуль очередей (https://github.com/tarantool/queue). У нас есть всякие внутренние разработки, которые невозможно генерализовать пока.
7. Опять же, благодаря Lua (правда это можно сделать и на SQL, то есть тут в основном это плюс хранимых процедур) можно делать read recovery при миграции данных.
8. Разработчики идут на контакт, принимают обратную связь и pull-request, даже если они не совсем рабочие. Спасибо Евгению за то, что поправил мой пулл реквест в очередь.

### Заключение.

1. 